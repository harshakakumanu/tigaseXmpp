<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;2.&nbsp;Tigase DB Schema Explained</title><link rel="stylesheet" type="text/css" href="css/docbook-xsl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Tigase Development Guide"><link rel="up" href="index.html" title="Tigase Development Guide"><link rel="prev" href="_tests.html" title="Chapter&nbsp;1.&nbsp;Tests"><link rel="next" href="_basic_information.html" title="Chapter&nbsp;3.&nbsp;Basic Information"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;2.&nbsp;Tigase DB Schema Explained</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="_tests.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="_basic_information.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_tigase_db_schema_explained"></a>Chapter&nbsp;2.&nbsp;Tigase DB Schema Explained</h1></div></div></div><p>Artur Hefczyc &lt;<a class="link" href="mailto:artur.hefczyc@tigase.net" target="_top">artur.hefczyc@tigase.net</a>&gt;
v2.0, June 2014: Reformatted for AsciiDoc.
:toc:
:numbered:
:website: <a class="link" href="http://tigase.net/" target="_top">http://tigase.net/</a>
:Date: 2011-07-12 00:56</p><p>The schema basics, how it looks like and brief explanation to all rows can be found in the <a class="link" href="https://projects.tigase.org/projects/tigase-server/repository/revisions/master/entry/database/mysql-schema-4-schema.sql" target="_top">schema creation script</a>. However, this is hardly enough to understand how it works and how access all the data. There are only 3 basic tables which actually keep all the Tigase server users' data: <span class="strong"><strong>tig_users</strong></span>, <span class="strong"><strong>tig_nodes</strong></span> and <span class="strong"><strong>tig_pairs</strong></span>. Therefore it is not clear at first how the Tigase data is organised.</p><p>Before you can understand the Tigase XMPP Server database schema, how it works and how to use it, is it essential to know what were the goals and why it works that way. Let&#8217;s start with the API as this gives you the best introduction.</p><p>Simplified access can be got through methods:</p><pre class="programlisting">void setData(BareJID user, String key, String value);
String getData(BareJID user, String key);</pre><p>And more complex version:</p><pre class="programlisting">void setData(BareJID user, String subnode, String key, String value);
String getData(BareJID user, String subnode, String key, String def);</pre><p>Even though, the API contanins more methods, the rest is more or less variation of presented above. Complete API description for all access methods is available in JavaDoc documentation to <a class="link" href="https://projects.tigase.org/projects/tigase-server/repository/entry/trunk/src/main/java/tigase/db/UserRepository.java" target="_top">UserRepository</a> interface. So we are not going into much details here except the main idea.</p><p>We are more or less operate on &lt;*key*, <span class="strong"><strong>value</strong></span>&gt; pairs for the particular user. The idea befind this was to make the API very simple and also at the same time very flexible, so adding a new plugin or component would not require database schema change, adding new tables, conversion of the DB schema to a new version, etc&#8230;&#8203;.</p><p>As a result <span class="strong"><strong>UserRepository</strong></span> interface is exposed to all the Tigase code, mainly components and plugins (let&#8217;s call all of them modules), and these modules simply call set/get methods to store or access module specific data.</p><p>As plugins or components are developed independently it may easily happen that developer choses the same key name to store some information. To avoid key name conclicts in the database a <span class="emphasis"><em>node</em></span> concept has been introduced. Therefore, most modules when set/get key value they also provide a subnode part, which in most cases is just XMLNS or some other unique string.</p><p>The <span class="emphasis"><em>node</em></span> thing is a little bit like directory in a filesystem, it may contain subnodes which makes the Tigase database kind of hierarchical structure. And the notation is also similar to filesystem. You use just '<span class="strong"><strong>/</strong></span>' to separate node levels. In practice you can have database organised like this:</p><pre class="programlisting">user-name@domain  --&gt; (key, value) pairs
                   |
               roster --&gt;
                       |
                     item1 --&gt; (key1, value1) pairs.
                       |
                     item2 --&gt; (key1, value1) pairs.</pre><p>So to access item&#8217;s 1 data from the roster you could call method like this:</p><pre class="programlisting">getData("user-name@domain", "roster/item1", key1, def1);</pre><p>This is huge convenience for the developer, as he can focus ont he module logic instead of worrying about data storage implementation and organisation. Especially at prototypic phase it speeds development up and allows for a quick experiments with differnent solutions. In practice, accessing user&#8217;s roster in such a way would be highly inefficient so the roster is stored a bit differently but you get the idea. Also there is a more complex API used in some places allowing for more direct access to the database and store data in any format optimised for the particular use case.</p><p>Right now such a hierarchical structure is implemented on top of SQL databases but initially Tigase&#8217;s database was implemented as XML structure, so it was natural and simple.</p><p>In the SQL database we simulate hierarchical structure with three tables:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><span class="strong"><strong>tig_users</strong></span> - with main users data, user id (JID), optional password, active flag, creation time and some other basic properties of the account. All of them could be actually stored in tig_pairs but for performance reasons they are in one place to quickly access them with single, simple query.</li><li class="listitem"><span class="strong"><strong>tig_nodes</strong></span> - is a table where the hierarchy is implemented. When Tigase was storing data in XML database the hierarchy was quite complex. However, in SQL database it resulted in a very slow access to the data and now more flat structure is used by most components. Please note, every user&#8217;s entry has something called root node, which is represented by <span class="emphasis"><em>root</em></span> string;</li><li class="listitem"><span class="strong"><strong>tig_pairs</strong></span> - this is the table where all the user&#8217;s information is stored in form of the &lt;key, value&gt; pairs.</li></ol></div><p>Ok, so we now know how the data is organised. Now we are going to learn how to access the data directly in the database using SQL queries.</p><p>Let&#8217;s assume we have a user <span class="emphasis"><em>admin@test-d</em></span> for whom we want to retrieve the roster. We could simply execute query:</p><pre class="programlisting">select pval
  from tig_users, tig_pairs
  where user_id = 'admin@test-d' and
        tig_users.uid = tig_pairs.uid and
        pkey = 'roster';</pre><p>However, if multiple modules store data under the key <span class="emphasis"><em>roster</em></span> for a single user, we would receive mutliple results. To access the correct <span class="emphasis"><em>roster</em></span> we have to know also node hierarchy for this particular key. The main user&#8217;s roster is stored under the <span class="emphasis"><em>root</em></span> node, so the query would look like:</p><pre class="programlisting">select pval
  from tig_users, tig_nodes, tig_pairs
  where user_id = 'admin@test-d' and
            tig_users.uid = tig_nodes.uid and
            node = 'root' and
            tig_users.uid = tig_pairs.uid and
           pkey = 'roster';</pre><p>How exactly the information is stored in the <span class="strong"><strong>tig_pairs</strong></span> table depends on the particular module. For the roster it looks a bit like XML content:</p><pre class="programlisting">&lt;contact jid="all-xmpp-test@test-d" subs="none" preped="simple" name="all-xmpp-test"/&gt;</pre></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="_tests.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="_basic_information.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;1.&nbsp;Tests&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;3.&nbsp;Basic Information</td></tr></table></div></body></html>